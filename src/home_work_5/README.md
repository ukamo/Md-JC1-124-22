Задача на умение работать с: Массивами, Дженериками, интерфейс Comparable (jdk), интерфейс Comparator (jdk).

!!! Запрещено использовать коллекции, stream api, лямбды, а также методы которые возвращают коллекции !!!

DataContainer:
Суть задания: Создать класс который может сохранять в себе почти любое количество данных обобщённого типа (GENERIC) и при этом внешне, благодаря инкапусляции, не будет иметь недостатков массива:
1. Данный класс умеет добавлять в себя данные обобщённого типа.
2. Данный класс умеет удалять данные из себя двумя способами: по индексу и конкретный элемент.
3. Данный класс умеет сортировать в себе данные. Но учитывайте что в данном функционале есть проблема. Как написать универсальный код сортировки и объяснить что один объект больше другого?
3.1 Короткий ответ: подсказывать нашему методу как сравнивать объекты сохранённые в нём.
3.2 Полный ответ: Для того чтобы написать более универсальный код, а также не гадать какого типа передадут данные и не придумывать способы сравнения этих данных, мы, при вызове сортировки, заставим передать реализацию сравнения (реализацию интерфейса Comparator) к которой нам нужно будет обращаться каждый раз когда нам нужно будет сравнить два объекта и которая скажет какой объект больше, а какой меньше или они равны.
4. Методы должны НАЗЫВАТЬСЯ ровно так как написано в задаче
Пример использования (примерно так должно выглядить):
DataContainer<String> container = new DataContainer<>(); //Тут есть подвох в конструкторе, он возможно будет выглядеть не так как тут написано, возможно туда придётся что-то передать, думайте пока сами
int index1 = container.add("Привет");
int index2 = container.add("Как дела");
int index3 = container.add("Работаю");
int index4 = container.add("Давай потом");
String text1 = container.get(index1);
String text2 = container.get(index2);
String text3 = container.get(index3);
String text4 = container.get(index4);
sout(text1); //Привет
sout(text2); //Как дела
sout(text3); //Работаю
sout(text4); //Давай потом
container.delete(text1);
sout(container.get(index1)); //Как дела
Задание:
1. Создать класс DataContainer у которого  есть один дженерик (обобщение). Например литерал T. Данный класс как раз и будет решать задачу поставленную перед нами: хранить неограниченное количество передаваемых объектов обобщённого типа.
2. Внутри DataContainer должно быть поле T[] data, внутренний массив, которое предназначено для хранения передаваемых объектов. Да, именно T[] а не Object[]. Если использовать Object[] то это будет опасно и постоянно придётся делать приведеление типов.
3. Из-за особенностей дженериков в данном классе обязательно будет присутствовать один конструктор DataContainer(T[]).
4. В данном классе должен быть метод int add(T item) который добавляет данные во внутреннее поле data и возвращает номер позиции в которую были вставлены данные, начиная с 0.
   4.1 Если поле data не переполнено то данные нужно добавлять в первую позицию (ячейку) после последней заполненной позиции (ячейки).
   4.1.1 Пример: data = [1, 2, 3, null, null, null]. Вызвали add(777). Должно получиться data = [1, 2, 3, 777, null, null]. Метод add вернёт число 3.
   4.1.2 Пример: data = [1, 2, 3, null, null, null]. Вызвали add(null). Должно получиться data = [1, 2, 3, null, null, null]. Метод add вернёт число -1. -1 будет индикатором того что данный элемент в наш контейнер вставлять нельзя.
   4.1.3 Пример: data = [1, null, 3, null, null, null]. Вызвали add(777). Должно получиться data = [1, 777, 3, null, null, null]. Метод add вернёт число 1.

   4.2 В случае если поле data переполнено, нужно придумать механизм который будет расширять пространство для новых элементов. Тут вам поможет Arrays.copyOf.
   4.2.1 Пример: data = [1, 2, 3]. Вызвали add(777). Должно получиться data = [1, 2, 3, 777]. Метод add вернёт число 3.
   4.2.2 Пример: data = []. Вызвали add(777). Должно получиться data = [777]. Метод add вернёт число 0.
5. В данном классе должен быть метод T get(int index).
   Данный метод получает из DataContainer'а, из поля data, предварительно сохранённый объект который мы передали на предыдущем шаге через метод add.
   5.1 Пример: data = []. Вызвали add(9999). Получили data = [9999]. Метод add вернул число 0. Вызываем get(0). Метод get возвращает 9999
   5.2 Пример: data = [9999]. Вызываем get(1). Метод get возвращает null
6. В данном классе должен быть метод T[] getItems(). Данный метод возвращает массив из поля data.

7. Добавить метод boolean delete(int index) который будет удалять элемент из нашего поля data по индексу.
   7.1 Метод возвращает true если у нас получилось удалить данные.
   7.1.1 Пример data = [1, 2, 3, 777]. Вызывают delete(3). Должно получиться data = [1, 2, 3]. Метод delete вернёт true
   7.2 Метод возвращает false если нет такого индекса.
   7.2.1 Пример data = [1, 2, 3, 777]. Вызывают delete(9). Должно получиться data = [1, 2, 3, 777]. Метод delete вернёт false
   7.3. Освободившуюся ячейку в поеле data необходимо удалить полностью. Пустых элементов не должно быть.
   7.3.1 Пример data = [1, 2, 3, 777]. Вызывают delete(2). Должно получиться data = [1, 2, 777]. Метод delete вернёт true

8. Добавить метод boolean delete(T item) который будет удалять элемент из нашего поля data.
   8.1 Метод возвращает false если передают null.
   8.1.1 Пример data = [1, 2, 3, 777]. Вызывают delete(null). Метод delete вернёт false a data = [1, 2, 3, 777]

   	8.1.2 Пример data = [1, 2, 3, 777, null]. Вызывают delete(null). Метод delete вернёт false a data = [1, 2, 3, 777, null]

   8.2 Метод возвращает true если у нас получилось удалить данные.

   	8.2.1 Пример data = [1, 2, 3, 777]. Вызывают delete(777). Должно получиться data = [1, 2, 3]. Метод delete вернёт true


	8.3 Метод возвращает false если нет такого элемента. 
		8.3.1 Пример data = [1, 2, 3, 777]. Вызывают delete(111). Должно получиться data = [1, 2, 3, 777]. Метод delete вернёт false
	8.4 Освободившуюся ячейку необходимо удалить полностью. Пустых элементов не должно быть.
	
		8.4.1 Пример data = [1, 2, 3, 777, 3]. Вызывают delete(3). Должно получиться data = [1, 2, 777, 3]. Метод delete вернёт true


9. Добавить НЕ СТАТИЧЕСКИЙ метод void sort(Comparator<.......> comparator).
   Данный метод занимается сортировкой данных записанных в поле data используя реализацию сравнения из ПЕРЕДАННОГО объекта comparator.
   Классом Arrays пользоваться запрещено.
   Интефейс Comparator обязательно должен быть реализован отдельным классом.
   9.1 Пример data = [3, 1, 3, 777]. Вызывают sort(....) передавая компаратор чисел. Должно получиться data = [1, 3, 3, 777]
   9.2 Пример data = ["i", "hello", "1", "Как домашка"]. Вызывают sort(....) передавая компаратор строк по длинне. Должно получиться data = ["i", "1", "hello", "Как домашка"]

10. Переопределить метод toString() в классе и выводить содержимое data без ячеек в которых хранится null.
    10.1 Пример data = [1, 2, 3, 777, 3]. Вызывают toString() у созданного DataContainer. Возвращается строка [1, 2, 3, 777, 3]
    10.2 Пример data = [1, 2, 3, null]. Вызывают toString() у созданного DataContainer. Возвращается строка [1, 2, 3]
    10.3 Пример data = []. Вызывают toString() у созданного DataContainer. Возвращается строка []
    11.* В DataContainer добавить СТАТИЧЕСКИЙ метод void sort(DataContainer<.............> container) с дженериком extends Comparable. Данный метод будет сортировать элементы в ПЕРЕДАННОМ объекте DataContainer используя реализацию сравнения вызываемый у хранимых объектов. Для этого надо сделать дженерик метод.
    12.* В DataContainer добавить СТАТИЧЕСКИЙ метод void sort(DataContainer<.............> container, Comparator<.......> comparator) который будет принимать объект DataContainer и реализацию интерфейса Comparator. Данный метод будет сортировать элементы в ПЕРЕДАННОМ объекте DataContainer используя реализацию сравнения из ПЕРЕДАННОГО объекта интерфейса Comparator.
    13.** Реализовать в DataContainer интерфейс Iterable